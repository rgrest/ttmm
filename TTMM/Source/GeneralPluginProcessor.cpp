/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "GeneralPluginProcessor.h"
#include "TimeTools.h"
//#include "FileWriter.h"

//==============================================================================
ttmm::GeneralPluginProcessor::GeneralPluginProcessor(const std::string name, size_t guiParametersSize)
    : name(name)
{
    guiParameters.resize(guiParametersSize);
}

juce::AudioProcessorEditor* ttmm::GeneralPluginProcessor::createEditor()
{
    return nullptr;
}

int ttmm::GeneralPluginProcessor::getNumPrograms()
{
    return 1; // NB: some hosts don't cope very well if you tell them there are 0
    // programs,
    // so this should be at least 1, even if you're not really implementing
    // programs.
}

int ttmm::GeneralPluginProcessor::getCurrentProgram() { return 0; }

void ttmm::GeneralPluginProcessor::setCurrentProgram(int index) {}

const juce::String ttmm::GeneralPluginProcessor::getProgramName(int index)
{
    return juce::String();
}

void ttmm::GeneralPluginProcessor::changeProgramName(
    int index, const juce::String& newName) {}

//==============================================================================
void ttmm::GeneralPluginProcessor::prepareToPlay(double samplerate,
    int samplesPerBlock)
{
    //ttmm::logfileGeneral->write("Initializing PluginProcessor " + name.toStdString());
    UNUSED(samplesPerBlock);
    this->samplerate = static_cast<Samplerate>(samplerate);
    this->sampleDuration = std::chrono::duration<double>(1.0 / samplerate);
    initialize(this->samplerate);
}

void ttmm::GeneralPluginProcessor::releaseResources() { shutdown(); }

void ttmm::GeneralPluginProcessor::processBlock(
    juce::AudioSampleBuffer& buffer, juce::MidiBuffer& midiMessages)
{

    TIMED_BLOCK("processBlock")

    // The number of i/o-channels is configured JUCE-internally. We are working
    // with the simplification of a stereo-io-plugin, so we can safely just
    // use the first two channels and ignore the rest.  However, we have to
    // verify that all channels JUCE is considering our output are being written
    // to.
    for (int i = 0; i < getNumOutputChannels(); ++i)
    {
        buffer.clear(i, 0, buffer.getNumSamples());
    }

    // our pair of actual stereo-io-channels
    AudioSignalType* channel0 = buffer.getWritePointer(0);
    AudioSignalType* channel1 = buffer.getWritePointer(1);
    AudioBuffer audioBuffer{ channel0, channel1, buffer.getNumSamples() };

    processAudioAndMidiSignals(audioBuffer, midiMessages);
}

//==============================================================================
void ttmm::GeneralPluginProcessor::getStateInformation(
    juce::MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void ttmm::GeneralPluginProcessor::setStateInformation(const void* data,
    int sizeInBytes)
{
}
